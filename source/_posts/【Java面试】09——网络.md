---
title: 【Java面试】09——网络（待整理）
date: 2019-03-20T09:16:05.372Z
tags: [Java]
categories: [Java]
---
- 网络

<!-- more -->

--------------------------------

- NIO SelectionKey
    SelectionKey包含四种事件：
    1. Connect, 即连接事件(TCP连接);
    2. Accept, 即确认事件;
    3. Read, 即读事件;
    4. Write, 即写事件;

- NIO
    客户端的SocketChannel支持 OP_CONNECT, OP_READ, OP_WRITE三个操作;
    服务端ServerSocketChannel支持OP_ACCEPT操作;
    在服务端由ServerSocketChannel的accept()方法产生的SocketChannel支持OP_READ, OP_WRITE操作.
    |	C/S	|	Channel类  |  OP_ACCEPT  |  OP_CONNECT  |  OP_WRITE  |  OP_READ  |
    |:--------|:--------|:--------|:--------|:--------|:--------|
    |  Client | SocketChannel| |Y|Y|Y|
    |  Server | ServerSocketChannel|Y||||
    |  Server | SocketChannel| ||Y|Y|

- TCP三次握手
    第一次握手：客户端发送TCP包，置SYN标志位为1，将初始序号X，保存在包头的序列号(Seq)里。
    第二次握手：服务端回应确认包，置SYN标志位为1，置ACK为X+1，将初始序列号Y，保存在包头的序列号里。
    第三次握手：客户端对服务端的确认包进行确认，置SYN标志位为0，置ACK为Y+1，置序列号为Z。

    思考：为什么不是两次或者四次？
    1. 两次的情况下，如果C端没有收到S端的回应，C端认为未建立连接，S端对已建立的连接保存必要的资源，如果存在大量的这种情况，S端会因为资源耗尽崩溃。
    2. 完全可靠的通信协议是不存在的，三次握手后C端和S端可以确认之前的通信情况，但是无法确认之后的情况；按照这个道理来说，四次后者五次或者更多次都是徒劳的。

- TCP四次挥手
    1. TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。
    2. 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
    3. 服务器关闭客户端的连接，发送一个FIN给客户端。
    4. 客户段发回ACK报文确认，并将确认序号设置为收到序号加1。

- TCP和UDP区别  
    1. TCP面向连接（如打电话要先拨号建立连接）; UDP是无连接的，即发送数据之前不需要建立连接
    2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
    3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
    4、每一条TCP连接只能是点到点的; UDP支持一对一，一对多，多对一和多对多的交互通信
    5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
    6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

- HTTPS建立连接的过程
    1. 浏览器将自己支持的一套加密规则发送给网站。
    2. 网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。
    3. 浏览器获得网站证书之后浏览器要做以下工作：
        a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。
        b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。
        c) 使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。
    4. 网站接收浏览器发来的数据之后要做以下的操作：
        a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。
        b) 使用密码加密一段握手消息，发送给浏览器。
    5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。

    思考：加密/界面算法有哪些？

参考链接：
<https://blog.csdn.net/to_be_better/article/details/54885684>
<https://www.cnblogs.com/ttltry-air/archive/2012/08/20/2647898.html>